{
    "contents" : "library(shiny)\n\nshinyServer(function(input, output, session) {\n  \n  # All aminoacids and their classification\n  amin <- c(\"R\", \"H\", \"K\", \"D\", \"E\", \"S\", \"T\", \"N\", \"Q\", \"C\", \"U\", \"G\", \"P\", \"A\", \"V\", \"I\", \"L\", \"M\", \"F\", \"Y\", \"W\", \"X\")\n  hb   <- c( 1 ,  1 ,  1 ,  2 ,  2 ,  3 ,  3 ,  3 ,  3 ,  3 ,  3 ,  3 ,  3 ,  4 ,  4,   4 ,  4 ,  4 ,  4 ,  4 ,  4  , 5 )\n  #        charged/basic    -acid-    ------------polar/uncharged---------    -------------hydrophibic-------------\n  \n  # The 'X' aminoacid represents any aminoacid. All characters not present in amin will be replaced with X, unless a 3-letter format is detected\n  \n  amin3 <-c(\"Arg\", \"His\", \"Lys\", \"Asp\", \"Glu\", \"Ser\", \"Thr\", \"Asn\", \"Gln\", \"Cys\", \"Sec\", \"Gly\", \"Pro\", \"Ala\",\n            \"Val\", \"Ile\", \"Leu\", \"Met\", \"Phe\", \"Tyr\", \"Trp\")\n  \n  # Peptide groups in terms of bonds, some do miss\n  \n  apolar <- c(\"V\", \"I\", \"L\", \"M\", \"F\", \"Y\", \"W\")\n  acid <- c(\"D\", \"E\")\n  basic <- c(\"R\", \"H\", \"K\")\n  hydrobond <- c(\"S\", \"N\", \"Q\")\n  \n  addPolygon <- function(shape, x, y, size, col, lwd, border) {\n    if (shape == \"Triangle\") {\n      a <- 2*size*2/sqrt(3) # Length of triangle size. r.res is half of the height.\n      xi <- c(x, x + a/2, x + a) - a/2 \n      yi <- c(y, y + size*2, y) - size*0.8 # Adjusts ypos to avoid overlap of label and triangle thin top\n    } else if (shape == \"Square\") {\n      xi <- c(x, x, x + size*2, x + size*2) - size\n      yi <- c(y, y + size*2, y + size*2, y) - size\n    } else if (shape == \"Diamond\") {\n      d <- 0.85 * size*2*sqrt(2) # Diagonal of the square, since it's rotated. 0.8 lowers it because the vertices make it look bigger\n      xi <- c(x, x + d/2, x + d, x + d/2) - d/2\n      yi <- c(y, y + d/2, y, y - d/2)\n    } else if (shape == \"Hexagon\") {\n      d <- 2*size*2/sqrt(3) # Hexagon diagonal\n      l <- 2*size/sqrt(3) # Distance between two vertices\n      p1 <- (d - l)/2 # y-axis movement step\n      xi <- c(x, x - size, x - size, x, x + size, x + size)\n      yi <- c(y, y + p1, y + p1 + l, y + d, y + p1 + l, y + p1) - d/2\n    } else { #Circle\n      thetas <- seq(0, 2*pi, length.out = 100)\n      xi <- size * sin(thetas) + x\n      yi <- size * cos(thetas) + y\n    }\n    polygon(xi, yi, col = col, lwd = lwd,\n            border = border)\n  }\n  \n  rotvec <- function (v, n) {\n    # Taken from wavethresh::guyrot\n    l <- length(v)\n    n <- n%%l\n    if (n == 0) \n      return(v)\n    tmp <- v[(l - n + 1):l]\n    v[(n + 1):l] <- v[1:(l - n)]\n    v[1:n] <- tmp\n    v\n  }\n  \n  #### Code for Helical Net ####\n\n  getHeight <- function() {\n    pepSeq <- input$seq\n    n <- nchar(pepSeq)\n    rws <- ceiling(n/7)\n    height <- 200*rws*input$ydist\n    height\n  }\n\n  netPlot <- function() {\n    pepSeq <- input$seq\n    \n    n <- nchar(pepSeq)\n    \n    width <- 300\n    rws <- ceiling(n/7)\n    #ydist <- 1\n    height <- 200*rws*input$ydist\n    \n    imarx <- width*input$imarx # margem interna x\n    imary <- height*input$imary # margem interna y\n    par(mar=c(0,0,0,0) + 0.1)\n    plot(1, type = \"n\", xlim = c(0, width), ylim = c(0, height),\n         xaxt = \"n\", yaxt = \"n\", xlab = \"\", ylab = \"\",\n         xaxs = \"i\", yaxs = \"i\", frame.plot = input$showBoxNet == \"Yes\")\n    #abline(h=c(imary, height-imary), v = c(imarx, width-imarx), lty = 2)\n    \n    lfrac <- 0.15\n    l <- width*lfrac\n    if (input$netDirection == \"1\") {\n      xpos <- c(4:1, 3:1+0.5)*(width - 2*imarx)/5 + imarx \n    } else {\n      xpos <- c(1:4, 1:3+0.5)*(width - 2*imarx)/5 + imarx \n    }\n    \n    # Changing start positions:\n    xpos <- rotvec(xpos, as.numeric(input$netStart) - 1)\n    \n    ptx <- rep(xpos, ceiling(n/7))[1:n]\n    \n    pty <- rev((1:n)*(height - 2*imary)/(n+1)) + imary\n    \n    # Adding guides behind\n    \n    if (input$showNetGuide == \"Yes\") {\n      ltyNetGuide <- as.numeric(input$netGuideLty)\n      lwdNetGuide <- as.numeric(input$netGuideLwd)\n      colNetGuide <- gray(1-as.numeric(input$netGuideCol))\n      \n      print(c(ltyNetGuide, lwdNetGuide, colNetGuide))\n      \n      lines(ptx, pty, lty = ltyNetGuide, lwd = lwdNetGuide, col = colNetGuide) \n    }\n    \n    res <- unlist(strsplit(pepSeq, \"\"))\n    fills <- hb[match(res, amin)]\n    \n    shp <- c(input$shp1, input$shp2, input$shp3, input$shp4, input$shp5)\n    cores <- c(input$col1, input$col2, input$col3, input$col4, input$col5)\n    bordersShow <- c(input$circBorder1, input$circBorder1,\n                     input$circBorder3, input$circBorder4, input$circBorder5)\n    \n    if (any(bordersShow == \"Yes\")) {\n      bordersCol <- c(input$circBorderCol1, input$circBorderCol2,\n                      input$circBorderCol3, input$circBorderCol4, input$circBorderCol5)\n      bordersCol[bordersShow != \"Yes\"] <- NA\n      bordersCol <- bordersCol[fills]\n      bordersWd <- as.numeric(c(input$circBorderWd1, input$circBorderWd2,\n                                input$circBorderWd3, input$circBorderWd4, input$circBorderWd5))\n      bordersWd <- bordersWd[fills]\n    } else {\n      bordersCol <- rep(NA, length(nMin))\n      bordersWd <- rep(1, length(nMin))\n    }\n    \n    shapes <- shp[fills]\n    \n    nres <- nchar(pepSeq) \n    numLabs <- c(input$labCol1, input$labCol2, input$labCol3, input$labCol4, input$labCol5)\n    \n    # Making labels\n    labType <- as.numeric(input$labType)\n    \n    resLab <-  if (labType == 0) {\n      \"\"\n    } else if (labType == 1) {\n      res\n    } else if (labType == 2) {\n      amin3[match(res, amin)]\n    } else if (labType == 3) {\n      paste0(res, seq_len(nres))\n    } else if (labType == 4) {\n      seq_len(nres)\n    }\n    \n    bondWd <- c(apolar = input$bond1Wd, acba = input$bond2Wd, hydro = input$bond3Wd)\n    bondTy <- c(apolar = input$bond1Ty, acba = input$bond2Ty, hydro = input$bond3Ty)\n    bondCol <- c(apolar = input$bond1Col, acba = input$bond2Col, hydro = input$bond3Col)\n    \n    for (i in seq_len(n)) {\n      # Detecting Bonds \n      \n      bond3 <- TRUE\n      if (res[i] %in% apolar && res[i + 3] %in% apolar) {\n        bond3type <- \"apolar\"\n      } else if ((res[i] %in% basic && res[i + 3] %in% acid) ||\n                 (res[i] %in% acid && res[i + 3] %in% basic)) {\n        bond3type <- \"acba\"\n      } else if (res[i] %in% hydrobond && res[i + 3] %in% hydrobond) {\n        bond3type <- \"hydro\"\n      } else {\n        bond3 <- FALSE\n        bond3type <- \"none\"\n      } \n      \n      bond4 <- TRUE\n      if (res[i] %in% apolar && res[i + 4] %in% apolar) {\n        bond4type <- \"apolar\"\n      } else if ((res[i] %in% basic && res[i + 4] %in% acid) ||\n                 (res[i] %in% acid && res[i + 4] %in% basic)) {\n        bond4type <- \"acba\"\n      } else if (res[i] %in% hydrobond && res[i + 4] %in% hydrobond) {\n        bond4type <- \"hydro\"\n      } else {\n        bond4 <- FALSE\n        bond4type <- \"none\"\n      } \n      # Adding bonds\n      #if (i < n-3 && res[i] == \"I\" && res[i+3] == \"I\") {\n      \n      if (input$netDirection == \"1\") {\n        # The min/max choice for broken bonds depends on the direction of the net\n        # We select the min or max functions to be the extremes depending on the direction\n        ext1 <- max\n        ext2 <- min\n      } else {\n        ext1 <- min\n        ext2 <- max\n      }\n      \n      lty3 <- if(nchar(bondTy[bond3type]) > 1) bondTy[bond3type] else as.numeric(bondTy[bond3type])\n      lty4 <- if(nchar(bondTy[bond4type]) > 1) bondTy[bond4type] else as.numeric(bondTy[bond4type])\n      \n      if (bond3) {\n        if(ptx[i] == ext1(ptx)) {\n          xdif <- (ptx[i] - ptx[i+3])/5\n          xp2 <- ptx[i] + xdif/2\n          yp2 <- pty[i] - (pty[i] - pty[i+3]+l)/3\n          segments(ptx[i+3], pty[i+3]+l/2, ext2(ptx) - xdif/2, yp2,\n                   lwd = as.numeric(bondWd[bond3type]), lty = lty3,\n                   col = bondCol[bond3type])\n        } else {\n          xp2 <- ptx[i+3]\n          yp2 <- pty[i+3]+l/2\n        }\n        segments(ptx[i], pty[i]-l/2, xp2, yp2,\n                 lwd = as.numeric(bondWd[bond3type]), lty = lty3,\n                 col = bondCol[bond3type])\n      }\n      #if (i < n-4 && res[i] == \"I\" && res[i+4] == \"I\") {\n      if (bond4) {\n        if(ptx[i] == ext2(ptx)) {\n          xdif <- (ptx[i+4] - ptx[i])/5\n          xp2 <- ptx[i] - xdif\n          yp2 <- pty[i] - (pty[i] - pty[i+4]+l/2)/2\n          segments(ptx[i+4], pty[i+4]+l/2, ext1(ptx) + xdif/2, yp2,\n                   lwd = as.numeric(bondWd[bond4type]), lty = lty4,\n                   col = bondCol[bond4type])\n        } else {\n          xp2 <- ptx[i+4]\n          yp2 <- pty[i+4]+l/2\n        }\n        segments(ptx[i], pty[i]-l/2, xp2, yp2,\n                 lwd = as.numeric(bondWd[bond4type]), lty = lty4,\n                 col = bondCol[bond4type])\n      }\n      \n      # Adding Residues Polygons\n      bwd <- bordersWd[i]\n      addPolygon(shape = shapes[i], \n                 x = ptx[i], y = pty[i],\n                 size = l/2, col = cores[fills][i],\n                 lwd = bwd, border = bordersCol[i])\n#       text(ptx[i], pty[i], label = resLab[i],\n#            cex = input$labCex/10, font = as.numeric(input$labFont),\n#            col = numLabs[fills])\n    }\n    \n    text(ptx, pty, label = resLab,\n         cex = input$labCex/10, font = as.numeric(input$labFont),\n         col = numLabs[fills])\n    \n    # Adding title/name. Later to be on top\n    \n    if (input$showTitle == \"Yes\") {\n      main <- input$txTitle\n      cex.main <- input$cexTitleNet/10\n      text(x = input$xTitleNet, y = input$yTitleNet, label = main,\n           cex = cex.main, adj = c(0.5, 0.5), font = 2)\n    }\n\n  }\n  \n  output$netPlot <- renderPlot(\n    # The auto option is disbled by default to avoid unecessary plot creation \n    # when another projection is being tested, since this is rather slow\n    # and require considerable resources when online\n    {\n      if(input$autoNet || is.null(lastWheel)) {\n        netPlot()\n        lastNet <<- recordPlot()\n      } else {\n        replayPlot(lastNet)\n      }\n    },\n    height = getHeight, width = 300)\n  \n  \n  #### Code for Helical Wheel ####\n  \n  # Function to add stripes inside circles\n  \n  circStripes <- function(r, n, x=0, y=0, col = \"black\", angle = 0) {\n    h <- seq(0, r, length.out = n - ((n-1) %/% 3))\n    angs <- 2 * acos((r-h)/r)\n    chord <- r * sqrt(2 - 2*cos(angs))\n    hp <- c(h-r, r-h)\n    x1 <- c(-chord/2+x, -chord/2+x, +chord/2+x, +chord/2+x)\n    y1 <- c(hp + y, hp + y)\n    a <- angle*pi/180\n    \n    x2 <- (x1 - x) * cos(a) - (y1 - y) * sin(a) + x\n    y2 <- (x1 - x) * sin(a) + (y1 - y) * cos(a) + y\n    len <- length(x1)\n    segments(x2[1:(len/2)], y2[1:(len/2)], x2[(len/2+1):len], y2[(len/2+1):len], col = col)\n  }\n  \n  # Wheel radius. Changing this just messes with some relative positions offsets.\n  r <- 10 #input$wheelsize # Raio do circulo grande  da figura\n  \n  lastWheel <- NULL\n  \n  helicalPlot <- function() {\n    \n    nHel <- input$period\n    perStep <- input$perStep\n    \n    #pos <- c(1, 6, 11, 16, 3, 8, 13, 18, 5, 10, 15, 2, 7, 12, 17, 4, 9, 14) \n    \n    # Creating the minimum positions for 18 residues\n    posMin <- 1\n    \n    for (i in 2:nHel) {\n      y <- posMin[i-1] + perStep + 1\n      if (y > nHel) y <- y - nHel\n      posMin[i] <- y\n    }\n    \n    # Reading the pepseq\n    pepSeq <- input$seq \n    \n    if ((nchar(gsub(\"[A-Z]\", \"\", pepSeq))/nchar(gsub(\"[a-z]\", \"\", pepSeq))) == 2) {\n      # Tries to detect 3-letter code and convert to 1-letter\n      pepSeq <- amin[match(pepSeq, amin3)]\n    } else {\n      # Converts everything to upper case. Making sure everything is matched and \n      # Also allows for unkown pep detection below safely\n      pepSeq <- toupper(pepSeq)\n      #updateTextInput(session, \"seq\", value = pepSeq)\n    }\n    \n    # Replacing every character that isn't in 'amin' with 'X'\n    splitSeq <- unlist(strsplit(pepSeq, \"\"))\n    anyAmin <- which(!splitSeq %in% amin)\n    if (length(anyAmin) > 0) {\n      splitSeq[anyAmin] <- \"X\"\n      pepSeq <- paste0(splitSeq, collapse = \"\")\n      #updateTextInput(session, \"seq\", value = pepSeq)\n    }\n    \n    # Number of aminoacids residues\n    nres <- nchar(pepSeq) \n    \n    output$resNumber <- renderUI(helpText(paste(\"Number of residues:\", nres)))\n    \n    nHelicals <- ceiling(nres/nHel)\n    \n    angs <- seq(acos(0), acos(0)+2*pi, length.out = nHel + 1) #Angulos para posicao de cada circulo pequeno\n    # acos(0) garante que o primeiro angulo terá como resultado um circulo no eixo x = 0 e y = max(y)\n    # acos(0)+2*pi faz o circulo dar uma volta completa\n    # nres + 1 é utilizado pois o ultimo ponto sempre coincide com o primeiro. Criamos um a mais e depois removemos o excedente.\n    \n    nMin <- if(nres < 18) 1:18 else 1:nres\n    \n    angs <- rep(angs, nHelicals)[nMin]\n    \n    # Order of the circles. \n    pos <- rep(posMin, nHelicals)[nMin]\n    \n    perim <- 2*pi*r #Perimetro do circulo grande\n    \n    innerOff <- rep(seq(1, 1-input$innRatio, length.out = nres)[order(pos[1:nHel])], nHelicals)[nMin]\n    \n    rotDirection <- if(input$direction == \"Clockwise\") -1 else 1\n    \n    ptx <- innerOff * (rotDirection*r) * cos(angs) # Pontos x\n    \n    pty <- innerOff * r * sin(angs) # Pontos y\n    \n    # Creating factor to multiply x and y and make them smaller for other circles\n    \n    nestFact <- (1/((nMin-1)%/%nHel + 1))^(1-input$nestRatio)\n    \n    ptxOrd <- ptx[pos] * nestFact\n    \n    ptyOrd <- pty[pos] * nestFact\n    \n    res.ratio <- input$circprop # Razao entre o tamanho (raio) do menor circulo em relacao ao maior (1)\n    \n    r.res.prop <- seq(res.ratio, 1, length.out = length(nMin)) # Measure that will be used to define the size of the residue polygon\n    \n    r.res.prop <- sqrt(r.res.prop / pi) # The circles should have the area, not the radius, proportional do the position. This fixes it based on A = pi * r * r\n    \n    # l.res.prop <- \n    \n    res.space <- input$circsize # Tentativa: espaçamento entre circulos\n    \n    r.res <- rev((perim / sum(r.res.prop)) * r.res.prop * res.space) # Tentativa: raio dos circulos em função do raio total\n    \n    cores <- c(input$col1, input$col2, input$col3, input$col4, input$col5)\n    \n    res <- unlist(strsplit(pepSeq, \"\"))\n    \n    #par(mar = c(0,0,0,input$marR)+0.1, xpd = TRUE)\n    #mpar()\n    \n    par(mar = c(0, 0, input$marT, input$marR)+0.1, xpd = TRUE)\n    \n    plot(ptx, pty, xlim = c(min(ptx, na.rm = TRUE) - max(r.res, na.rm = TRUE),\n                            max(ptx, na.rm = TRUE) + max(r.res, na.rm = TRUE)),\n         ylim = c(min(pty, na.rm = TRUE) - max(r.res, na.rm = TRUE),\n                  max(pty, na.rm = TRUE) + max(r.res, na.rm = TRUE)),\n         type = \"n\", xaxt = \"n\", yaxt = \"n\", frame.plot = FALSE,\n         xlab = \"\", ylab = \"\", main = NA) # Preparando a area de plotagem, nao vai aparecer nada...\n    \n    \n    # Adding circles guides. Before other stuff to stay behind everything\n    \n    if (input$showWheelGuide == \"Yes\") {\n      angs.guide <- seq(0, 2*pi, length.out = nHel)\n      \n      ptx.guide <- - r * sin(angs.guide)\n      pty.guide <- r * cos(angs.guide)\n      \n      lty <- as.numeric(input$wheelGuideLty)\n      lwd <- as.numeric(input$wheelGuideLwd)\n      col <- gray(1-as.numeric(input$wheelGuideCol))\n      \n      for (nest in unique(nestFact)) {\n        lines(ptx.guide*nest, pty.guide*nest, lty = lty,\n              lwd = lwd, col = col)  \n      }\n    }\n    \n    line_grad <- seq(1-input$maxlinegray, 1-input$minlinegray, length.out = nres)\n    \n    for (i in rev(seq_len(nres-1))) { #Plotando as conexões. \n      # De tras para frente para sobreposicao ficar correta\n      sx0 <- ptxOrd[i]\n      sx1 <- ptxOrd[i+1]\n      sy0 <- ptyOrd[i]\n      sy1 <- ptyOrd[i+1]\n      segments(sx0, sy0, sx1, sy1, lwd = input$conLineWd, col =  gray(line_grad[i]))\n    }\n    \n    # This matches which circle is of which category to properly select the colors and grid styles\n    fills <- hb[match(res, amin)]\n    \n    bordersShow <- c(input$circBorder1, input$circBorder1,\n                     input$circBorder3, input$circBorder4, input$circBorder5)\n    \n    if (any(bordersShow == \"Yes\")) {\n      bordersCol <- c(input$circBorderCol1, input$circBorderCol2,\n                      input$circBorderCol3, input$circBorderCol4, input$circBorderCol5)\n      bordersCol[bordersShow != \"Yes\"] <- NA\n      bordersCol <- bordersCol[fills]\n      bordersWd <- as.numeric(c(input$circBorderWd1, input$circBorderWd2,\n                                input$circBorderWd3, input$circBorderWd4, input$circBorderWd5))\n      bordersWd <- bordersWd[fills]\n    } else {\n      bordersCol <- rep(NA, length(nMin))\n      bordersWd <- rep(1, length(nMin))\n    }\n    \n    # Ploting the polygons\n\n    shp <- c(input$shp1, input$shp2, input$shp3, input$shp4, input$shp5)\n    \n    shapes <- shp[fills]\n    \n    for (i in nMin) {\n      bwd <- bordersWd[i]\n      if (is.na(bwd)) next # Avoiding errors with invalid lwd. NA throwns an error, skip because there's no circle to plot\n      \n      addPolygon(shape = shapes[i], \n                 x = ptxOrd[i], y = ptyOrd[i],\n                 size = r.res[i], col = cores[fills][i],\n                 lwd = bwd, border = bordersCol[i])\n      \n      # if (shapes[i] == \"Triangle\") { \n      #         a <- 2*r.res[i]*2/sqrt(3) # Length of triangle size. r.res is half of the height.\n      #         xi <- c(ptxOrd[i], ptxOrd[i] + a/2, ptxOrd[i] + a) - a/2 \n      #         yi <- c(ptyOrd[i], ptyOrd[i] + r.res[i]*2, ptyOrd[i]) - r.res[i]*0.8 # Adjusts ypos to avoid overlap of label and triangle thin top\n      #       } else if (shapes[i] == \"Square\") { \n      #         xi <- c(ptxOrd[i], ptxOrd[i], ptxOrd[i] + r.res[i]*2, ptxOrd[i] + r.res[i]*2) - r.res[i]\n      #         yi <- c(ptyOrd[i], ptyOrd[i] + r.res[i]*2, ptyOrd[i] + r.res[i]*2, ptyOrd[i]) - r.res[i]\n      #       } else if (shapes[i] == \"Diamond\") {\n      #         d <- 0.85 * r.res[i]*2*sqrt(2) # Diagonal of the square, since it's rotated. 0.8 lowers it because the vertices make it look bigger\n      #         xi <- c(ptxOrd[i], ptxOrd[i] + d/2, ptxOrd[i] + d, ptxOrd[i] + d/2) - d/2\n      #         yi <- c(ptyOrd[i], ptyOrd[i] + d/2, ptyOrd[i], ptyOrd[i] - d/2)\n      #       } else if (shapes[i] == \"Hexagon\") {\n      #         d <- 2*r.res[i]*2/sqrt(3) # Hexagon diagonal\n      #         l <- 2*r.res[i]/sqrt(3) # Distance between two vertices\n      #         p1 <- (d - l)/2 # y-axis movement step\n      #         xi <- c(ptxOrd[i], ptxOrd[i] - r.res[i], ptxOrd[i] - r.res[i], ptxOrd[i], ptxOrd[i] + r.res[i], ptxOrd[i] + r.res[i])\n      #         yi <- c(ptyOrd[i], ptyOrd[i] + p1, ptyOrd[i] + p1 + l, ptyOrd[i] + d, ptyOrd[i] + p1 + l, ptyOrd[i] + p1) - d/2\n      #       } else { # Circles\n      #         xi <- r.res[i] * sin(thetas) + ptxOrd[i]\n      #         yi <- r.res[i] * cos(thetas) + ptyOrd[i]\n      #       }\n      #       \n      #       polygon(xi, yi, col = cores[fills][i], lwd = bwd,\n      #               border = bordersCol[i])\n    }\n    \n    # Fill styles\n    \n    circsFills <- c(input$fill1, input$fill2, input$fill3, input$fill4, input$fill5)\n    \n    styles <- circsFills[fills]\n    \n    styles.angs <- c(n = -1, h = 0, v = 90, `d/` = 45, `d\\\\` = -45)\n    \n    if (any(styles != \"n\")) {\n      nFills <- as.numeric(c(input$nFills1, input$nFills2, input$nFills3, input$nFills4, input$nFills5))\n      nFills <- nFills[fills]\n      fillCol <- c(input$fillCol1, input$fillCol2, input$fillCol3, input$fillCol4, input$fillCol5)\n      fillCol <- fillCol[fills]\n      angs.pattern <- styles.angs[match(styles, names(styles.angs))]\n      for (i in nMin) {\n        if (!is.na(styles[i]) && styles[i] != \"n\" && shapes[i] == \"Circle\") {\n          #           ang <- if(styles[i] == \"h\") {\n          #             0\n          #           } else if (styles[i] == \"v\") {\n          #             90\n          #           } else if (styles[i] == \"d/\") {\n          #             45\n          #           } else if (styles[i] == \"d\\\\\") {\n          #             -45\n          #           }\n          circStripes(r = r.res[i], n = nFills[i],\n                      x = ptxOrd[i], y = ptyOrd[i],\n                      angle = angs.pattern[i], col = fillCol[i])\n        }\n      }\n      \n      # Adding the cicle borders again...\n      \n      #       for (i in nMin) {\n      #         xi <- r.res[i] * sin(thetas) + ptxOrd[i]\n      #         yi <- r.res[i] * cos(thetas) + ptyOrd[i]\n      #         polygon(xi, yi, col = NA, lwd = bordersWd[i],\n      #                 border = bordersCol[i])\n      #       }\n    }\n    \n    # Using symbols is dangerous. The drawings are relative to the axis and drawings may be hard to position\n    #     symbols(ptxOrd, ptyOrd, circles = r.res, inches = FALSE, \n    #             add = TRUE, bg = cores[fills], \n    #             fg = circBorder, lwd = input$circBorderWd) #Plotando os circulos\n    \n    # Making labels\n    labType <- as.numeric(input$labType)\n    \n    resLab <-  if (labType == 0) {\n      \"\"\n    } else if (labType == 1) {\n      res\n    } else if (labType == 2) {\n      amin3[match(res, amin)]\n    } else if (labType == 3) {\n      paste0(res, seq_len(nres))\n    }\n    \n    labOffX <- input$labOffX\n    labOffY <- input$labOffY\n    \n    numLabs <- c(input$labCol1, input$labCol2, input$labCol3, input$labCol4, input$labCol5)\n    \n    text(ptxOrd + r.res*(sign(labOffX)) + labOffX,\n         ptyOrd + r.res*(sign(labOffY)) + labOffY,\n         label = resLab,\n         cex = input$labCex/10, font = as.numeric(input$labFont),\n         col = numLabs[fills])\n    \n    # Adding the residues number\n    \n    if (input$numShow == \"Yes\") {\n      numOffY <- input$numOffY\n      numOffX <- -input$numOffX\n      \n      numCols <- c(input$numCol1, input$numCol2, input$numCol3, input$numCol4, input$numCol5)\n      \n      text(ptxOrd - r.res*(sign(numOffX)) - numOffX, \n           ptyOrd - r.res*(sign(numOffY)) - numOffY, \n           labels = seq_len(nres), cex = input$numCex/10, \n           font = as.numeric(input$numFont),\n           col = numCols[fills]) \n    }\n    \n    if (input$showLeg == \"Yes\") {\n      legLab <- c(input$leg1, input$leg2, input$leg3, input$leg4, input$leg5)\n      legFill <- c(input$col1, input$col2, input$col3, input$col4, input$col5)\n      if (!grepl(\"X\", pepSeq)) {\n        legLab <- legLab[1:4]\n        legFill <- legFill[1:4]\n      }\n      \n      # Defining a legend function to avoid repeating the same arguments below if necessary\n      \n      my.leg <- function(...) legend(x = r*input$legX, y = r*input$legY, \n                                     legend = legLab,\n                                     bty = \"n\", yjust = 0.5, cex = as.numeric(input$legCex)/10, ...)\n      \n      # Now just calls with standard arguments and colouring fill\n      \n      my.leg(fill = legFill)\n      \n      # Adding pattern on legend\n      \n      angs.pattern <- styles.angs[match(circsFills, names(styles.angs))]\n      #print(angs.pattern)\n      if (any(!is.na(angs.pattern))) {\n        \n        legDen <- c(input$legDen1, input$legDen2, input$legDen3, input$legDen4, input$legDen5)\n        \n        my.leg(fill = ifelse(angs.pattern  == -1, adjustcolor(\"black\", 0), \"black\"),\n               density = ifelse(angs.pattern == -1, NA, legDen),\n               angle = angs.pattern)\n      }\n    }\n    \n    # Adding title/name. Later to be on top\n    \n    if (input$showTitle == \"Yes\") {\n      main <- input$txTitle\n      cex.main <- input$cexTitle/10\n      text(x = input$xTitle, y = input$yTitle, label = main,\n           cex = cex.main, adj = c(0.5, 0.5), font = 2)\n    }\n    \n    # Adding outer box to help exporting\n    \n    if (input$showBox == \"Yes\") {\n      box(\"outer\") \n    }\n    \n  }\n  \n  imgWd <- reactive(input$figWd)\n  #getSeq <- reactive(input$seq)\n  \n  output$helicalPlot <- renderPlot({\n    # The auto option is disbled by default to avoid unecessary plot creation \n    # when another projection is being tested, since this is rather slow\n    # and require considerable resources when online\n    if(input$autoWheel || is.null(lastWheel)) {\n      helicalPlot()\n      lastWheel <<- recordPlot()\n    } else {\n      #print(class(lastWheel))\n      replayPlot(lastWheel)\n    }\n  },\n  height = 600, width = imgWd)\n  \n  #shinyjs::disable(\"wheelsize\")\n  \n  # Use sequence as title\n  observeEvent(input$titleSeq, {\n    updateSelectInput(session, \"showTitle\", selected = \"Yes\")\n    updateTextInput(session, \"txTitle\", value = input$seq)\n    nc <- nchar(input$seq)\n    cexFit <- round(0.0325*nc^2 - 2.275*nc + 49.5, 1)\n    updateNumericInput(session, \"cexTitle\", value = cexFit)\n  })\n  \n  # Reseting and style buttons\n  \n  observeEvent(input$reset_input, {\n    shinyjs::reset(\"side-panel\")\n  })\n  \n  observeEvent(input$reset_input2, {\n    shinyjs::reset(\"settings\")\n  })\n  \n  \n  observeEvent(input$style_gray, {\n    shinyjs::updateColourInput(session = session, inputId = \"col1\", value = \"black\")\n    updateTextInput(session = session, inputId = \"circBorder1\", value = \"No\")\n    shinyjs::updateColourInput(session = session, inputId = \"circBorderCol1\", value = \"#000000\")\n    shinyjs::updateColourInput(session = session, inputId = \"labCol1\", value = \"#FFFFFF\")\n    shinyjs::updateColourInput(session = session, inputId = \"col2\", value = \"gray30\")\n    updateTextInput(session = session, inputId = \"circBorder1\", value = \"No\")\n    shinyjs::updateColourInput(session = session, inputId = \"circBorderCol2\", value = \"#000000\")\n    shinyjs::updateColourInput(session = session, inputId = \"labCol2\", value = \"#FFFFFF\")\n    shinyjs::updateColourInput(session = session, inputId = \"col3\", value = \"gray50\")\n    updateTextInput(session = session, inputId = \"circBorder3\", value = \"No\")\n    shinyjs::updateColourInput(session = session, inputId = \"circBorderCol3\", value = \"#000000\")\n    shinyjs::updateColourInput(session = session, inputId = \"labCol3\", value = \"#000000\")\n    shinyjs::updateColourInput(session = session, inputId = \"col4\", value = \"gray80\")\n    updateTextInput(session = session, inputId = \"circBorder4\", value = \"No\")\n    shinyjs::updateColourInput(session = session, inputId = \"circBorderCol4\", value = \"#000000\")\n    shinyjs::updateColourInput(session = session, inputId = \"labCol4\", value = \"#000000\")\n    shinyjs::updateColourInput(session = session, inputId = \"col5\", value = \"white\")\n    updateTextInput(session = session, inputId = \"circBorder5\", value = \"Yes\")\n    shinyjs::updateColourInput(session = session, inputId = \"circBorderCol5\", value = \"#000000\")\n    shinyjs::updateColourInput(session = session, inputId = \"labCol5\", value = \"#000000\")\n  })\n  \n  observeEvent(input$style_bw, {\n    shinyjs::updateColourInput(session = session, inputId = \"col1\", value = \"#FFFFFF\")\n    updateTextInput(session = session, inputId = \"circBorder1\", value = \"Yes\")\n    shinyjs::updateColourInput(session = session, inputId = \"circBorderCol1\", value = \"#000000\")\n    shinyjs::updateColourInput(session = session, inputId = \"labCol1\", value = \"#000000\")\n    updateSelectInput(session = session, inputId = \"fill1\", selected = \"n\")\n    updateNumericInput(session = session, inputId = \"nFills1\", value = \"4\")\n    shinyjs::updateColourInput(session = session, inputId = \"fillCol1\", value = \"#FFFFFF\")\n    \n    shinyjs::updateColourInput(session = session, inputId = \"col2\", value = \"#FFFFFF\")\n    updateTextInput(session = session, inputId = \"circBorder1\", value = \"Yes\")\n    shinyjs::updateColourInput(session = session, inputId = \"circBorderCol2\", value = \"#000000\")\n    shinyjs::updateColourInput(session = session, inputId = \"labCol2\", value = \"#000000\")\n    updateSelectInput(session = session, inputId = \"fill2\", selected = \"v\")\n    updateNumericInput(session = session, inputId = \"nFills2\", value = \"4\")\n    shinyjs::updateColourInput(session = session, inputId = \"fillCol2\", value = \"#000000\")\n    \n    shinyjs::updateColourInput(session = session, inputId = \"col3\", value = \"#FFFFFF\")\n    updateTextInput(session = session, inputId = \"circBorder3\", value = \"Yes\")\n    shinyjs::updateColourInput(session = session, inputId = \"circBorderCol3\", value = \"#000000\")\n    shinyjs::updateColourInput(session = session, inputId = \"labCol3\", value = \"#000000\")\n    updateSelectInput(session = session, inputId = \"fill3\", selected = \"h\")\n    updateNumericInput(session = session, inputId = \"nFills3\", value = \"4\")\n    shinyjs::updateColourInput(session = session, inputId = \"fillCol3\", value = \"#000000\")\n    \n    shinyjs::updateColourInput(session = session, inputId = \"col4\", value = \"#FFFFFF\")\n    updateTextInput(session = session, inputId = \"circBorder4\", value = \"Yes\")\n    shinyjs::updateColourInput(session = session, inputId = \"circBorderCol4\", value = \"#000000\")\n    shinyjs::updateColourInput(session = session, inputId = \"labCol4\", value = \"#000000\")\n    updateSelectInput(session = session, inputId = \"fill4\", selected = \"d/\")\n    updateNumericInput(session = session, inputId = \"nFills4\", value = \"3\")\n    shinyjs::updateColourInput(session = session, inputId = \"fillCol4\", value = \"#000000\")\n    \n    shinyjs::updateColourInput(session = session, inputId = \"col5\", value = \"#FFFFFF\")\n    updateTextInput(session = session, inputId = \"circBorder5\", value = \"Yes\")\n    shinyjs::updateColourInput(session = session, inputId = \"circBorderCol5\", value = \"#000000\")\n    shinyjs::updateColourInput(session = session, inputId = \"labCol5\", value = \"#000000\")\n    updateSelectInput(session = session, inputId = \"fill5\", selected = \"d\\\\\")\n    updateNumericInput(session = session, inputId = \"nFills5\", value = \"3\")\n    shinyjs::updateColourInput(session = session, inputId = \"fillCol5\", value = \"#000000\")\n    \n    updateNumericInput(session = session, inputId = \"maxlinegray\", value = 1)\n    updateNumericInput(session = session, inputId = \"minlinegray\", value = 1)\n    updateNumericInput(session = session, inputId = \"conLineWd\", value = 1)\n  })\n  \n  observeEvent(input$style_labdown, {\n    current <- input$labType\n    \n    if (current == \"0\") {\n      updateSelectInput(session = session, inputId = \"numShow\", selected = \"Yes\")\n      updateSelectInput(session = session, inputId = \"labType\", selected = \"1\")\n      updateNumericInput(session = session, inputId = \"labOffY\", value = 0)\n      updateNumericInput(session = session, inputId = \"lnumOffY\", value = -0.3)\n    } else if (current == \"1\") {\n      updateSelectInput(session = session, inputId = \"labType\", selected = \"2\")\n    } else if (current == \"2\") {\n      updateSelectInput(session = session, inputId = \"numShow\", selected = \"No\")\n      updateSelectInput(session = session, inputId = \"labType\", selected = \"3\")\n      updateNumericInput(session = session, inputId = \"labOffY\", value = -0.3)\n    } else if (current == \"3\") {\n      if (input$labOffY == -0.3) {\n        updateNumericInput(session = session, inputId = \"labOffY\", value = 0)\n      } else {\n        updateSelectInput(session = session, inputId = \"numShow\", selected = \"No\")\n      updateSelectInput(session = session, inputId = \"labType\", selected = \"0\")\n      }\n    } \n    shinyjs::updateColourInput(session = session, inputId = \"labCol1\", value = \"#000000\")\n    shinyjs::updateColourInput(session = session, inputId = \"labCol2\", value = \"#000000\")\n    shinyjs::updateColourInput(session = session, inputId = \"labCol3\", value = \"#000000\")\n    shinyjs::updateColourInput(session = session, inputId = \"labCol4\", value = \"#000000\")\n    shinyjs::updateColourInput(session = session, inputId = \"labCol5\", value = \"#000000\")\n    \n  })\n  \n  observeEvent(input$style_round, {\n    if (input$innRatio != 0) {\n      updateNumericInput(session, \"innRatio\", value = 0)\n    } else {\n      updateNumericInput(session, \"innRatio\", value = 0.4)  \n    }\n  })\n  \n  observeEvent(input$style_legend, {\n    if (input$showLeg == \"No\") {\n      updateSelectInput(session, \"showLeg\", selected = \"Yes\")\n      updateNumericInput(session, \"figWd\", value = 775)\n      updateNumericInput(session, \"marR\", value = 12)\n      updateNumericInput(session, \"marT\", value = 0)\n    } else {\n      updateSelectInput(session, \"showLeg\", selected = \"No\")\n      updateNumericInput(session, \"figWd\", value = 600)\n      updateNumericInput(session, \"marR\", value = 0)\n      updateNumericInput(session, \"marT\", value = 0)\n    }\n  })\n  \n  observeEvent(input$style_circle, {\n    updateSelectInput(session = session, inputId = \"shp1\", selected = \"Circle\")\n    updateSelectInput(session = session, inputId = \"shp2\", selected = \"Circle\")\n    updateSelectInput(session = session, inputId = \"shp3\", selected = \"Circle\")\n    updateSelectInput(session = session, inputId = \"shp4\", selected = \"Circle\")\n    updateSelectInput(session = session, inputId = \"shp5\", selected = \"Circle\")\n  })\n  \n  observeEvent(input$style_squares, {\n    updateSelectInput(session = session, inputId = \"shp1\", selected = \"Square\")\n    updateSelectInput(session = session, inputId = \"shp2\", selected = \"Square\")\n    updateSelectInput(session = session, inputId = \"shp3\", selected = \"Square\")\n    updateSelectInput(session = session, inputId = \"shp4\", selected = \"Square\")\n    updateSelectInput(session = session, inputId = \"shp5\", selected = \"Square\")\n  })\n  \n  observeEvent(input$style_shapes, {\n    updateSelectInput(session = session, inputId = \"shp1\", selected = \"Circle\")\n    updateSelectInput(session = session, inputId = \"shp2\", selected = \"Square\")\n    updateSelectInput(session = session, inputId = \"shp3\", selected = \"Triangle\")\n    updateSelectInput(session = session, inputId = \"shp4\", selected = \"Diamond\")\n    updateSelectInput(session = session, inputId = \"shp5\", selected = \"Hexagon\")\n  })\n  \n  observeEvent(input$bt_rdata, {\n    save.image(\"Image.RData\")\n  })\n  \n  observeEvent(input$bt_rdataload, {\n    load(\"Image.RData\")\n  })\n  \n  observeEvent(input$bt_force, {\n    updateSelectInput(session, \"circBorder1\", selected = \"Yes\")\n  })\n \n  \n  output$bt_export <- downloadHandler(\n    filename = function() {\n      \"HelicalWheelStyle.hws\"\n    },\n    content = function(file) {\n      vlist <- reactiveValuesToList(input)\n      # Remove this values because they aren't inputs and can be dangerous\n      vlist[c(\"fileImport\", \"shinyjs-resettable-settings\")] <- NULL\n      #print(vlist)\n      inputsList <- names(vlist)\n      exportVars <- paste0(inputsList, \"=\", sapply(inputsList, function(inpt) input[[inpt]]))\n      write(exportVars, file)\n    })\n  \n  importFile <- reactive({\n    \n    inFile <- input$fileImport\n    #print(\"a\")\n    if (is.null(inFile))\n      return(NULL)\n    \n    lines <- readLines(inFile$datapath)\n    out <- lapply(lines, function(l) unlist(strsplit(l, \"=\")))\n    #shinyjs::reset(\"fileImport\")\n    return(out)\n  })\n  \n  observe({\n    imp <- importFile()\n\n    if (!is.null(imp)) {\n      imp <- imp[order(sapply(imp, function(o) nchar(o[1])))]\n\n      for (inpt in imp) session$sendInputMessage(inpt[1], list(value = inpt[2]))\n      \n      # This is a workaround to make sure reuploading the file will work properly. \n      Sys.sleep(1)\n      session$sendCustomMessage(type = \"resetFileInputHandler\", 'fileImport')\n    }\n  })\n  \n  fname <- \"HelicalWheelProjection\"\n  \n  output$plotDown <- downloadHandler(\n    filename = function() {\n      paste(fname, tolower(input$expFormat), sep = \".\")\n    },\n    content = function(file) {\n      dpi <- input$expDPI\n      dims <- as.numeric(dpi)*c(input$figWd, 600)/72\n      if (input$expFormat == \"PNG\") {\n        png(file, res = dpi, width = dims[1], height = dims[2])\n      } else if (input$expFormat == \"TIFF\") {\n        tiff(file, compression = \"lzw\", res = dpi, width = dims[1], height = dims[2])\n      } else if (input$expFormat == \"PDF\") {\n        pdf(file, width = input$figWd/72, height = 600/72)\n      } else if (input$expFormat == \"JPG\") {\n        jpeg(file, res = dpi, width = dims[1], height = dims[2], quality = 100)\n      }\n      par(mar = c(0, 0, input$marT, input$marR)+0.1, xpd = TRUE)\n      helicalPlot()\n      dev.off()\n    }\n  )\n  \n  fnameNet <- \"HelicalNetProjection\"\n  \n  output$plotDownNet <- downloadHandler(\n    filename = function() {\n      paste(fnameNet, tolower(input$expFormatNet), sep = \".\")\n    },\n    content = function(file) {\n      dpi <- input$expDPINet\n      dims <- as.numeric(dpi)*c(300, getHeight())/72\n      ImgFormat <- input$expFormatNet \n      if (ImgFormat == \"PNG\") {\n        png(file, res = dpi, width = dims[1], height = dims[2])\n      } else if (ImgFormat == \"TIFF\") {\n        tiff(file, compression = \"lzw\", res = dpi, width = dims[1], height = dims[2])\n      } else if (ImgFormat == \"PDF\") {\n        pdf(file, width = 300/72, height = getHeight()/72)\n      } else if (ImgFormat == \"JPG\") {\n        jpeg(file, res = dpi, width = dims[1], height = dims[2], quality = 100)\n      }\n      par(mar=c(0,0,0,0) + 0.1)\n      netPlot()\n      dev.off()\n    }\n  )\n})\n",
    "created" : 1445557294124.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2515112111",
    "id" : "472DC51B",
    "lastKnownWriteTime" : 1445559473,
    "path" : "D:/Google Drive/R/Shiny/HelicalWheel/server.R",
    "project_path" : "server.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "type" : "r_source"
}