{
    "contents" : "library(shiny)\n\n# These objects aren't reactive, they are written here so they are only created once for the whole app, and not for every session.\n\naddPolygon <- function(shape, x, y, size, col, lwd, border) {\n  if (shape == \"Triangle\") {\n    a <- 2*size*2/sqrt(3) # Length of triangle size. r.res is half of the height.\n    xi <- c(x, x + a/2, x + a) - a/2 \n    yi <- c(y, y + size*2, y) - size*0.8 # Adjusts ypos to avoid overlap of label and triangle thin top\n  } else if (shape == \"Square\") {\n    xi <- c(x, x, x + size*2, x + size*2) - size\n    yi <- c(y, y + size*2, y + size*2, y) - size\n  } else if (shape == \"Diamond\") {\n    d <- 0.85 * size*2*sqrt(2) # Diagonal of the square, since it's rotated. 0.8 lowers it because the vertices make it look bigger\n    xi <- c(x, x + d/2, x + d, x + d/2) - d/2\n    yi <- c(y, y + d/2, y, y - d/2)\n  } else if (shape == \"Hexagon\") {\n    d <- 2*size*2/sqrt(3) # Hexagon diagonal\n    l <- 2*size/sqrt(3) # Distance between two vertices\n    p1 <- (d - l)/2 # y-axis movement step\n    xi <- c(x, x - size, x - size, x, x + size, x + size)\n    yi <- c(y, y + p1, y + p1 + l, y + d, y + p1 + l, y + p1) - d/2\n  } else { #Circle\n    thetas <- seq(0, 2*pi, length.out = 100)\n    xi <- size * sin(thetas) + x\n    yi <- size * cos(thetas) + y\n  }\n  polygon(xi, yi, col = col, lwd = lwd,\n          border = border)\n}\n\n# Function to add stripes inside circles\n\ncircStripes <- function(r, n, x=0, y=0, col = \"black\", angle = 0) {\n  h <- seq(0, r, length.out = n - ((n-1) %/% 3))\n  angs <- 2 * acos((r-h)/r)\n  chord <- r * sqrt(2 - 2*cos(angs))\n  hp <- c(h-r, r-h)\n  x1 <- c(-chord/2+x, -chord/2+x, +chord/2+x, +chord/2+x)\n  y1 <- c(hp + y, hp + y)\n  a <- angle*pi/180\n  \n  x2 <- (x1 - x) * cos(a) - (y1 - y) * sin(a) + x\n  y2 <- (x1 - x) * sin(a) + (y1 - y) * cos(a) + y\n  len <- length(x1)\n  segments(x2[1:(len/2)], y2[1:(len/2)], x2[(len/2+1):len], y2[(len/2+1):len], col = col)\n}\n\n#   rotvec <- function (v, n) {\n#     # Taken from wavethresh::guyrot\n#     l <- length(v)\n#     n <- n%%l\n#     if (n == 0) \n#       return(v)\n#     tmp <- v[(l - n + 1):l]\n#     v[(n + 1):l] <- v[1:(l - n)]\n#     v[1:n] <- tmp\n#     v\n#   }\n\nshinyServer(function(input, output, session) {\n  \n  ## All aminoacids and their classification\n  #amin <- c(\"R\", \"H\", \"K\", \"D\", \"E\", \"S\", \"T\", \"N\", \"Q\", \"C\", \"U\", \"P\", \"A\", \"G\", \"V\", \"I\", \"L\", \"M\", \"F\", \"Y\", \"W\", \"X\")\n  #hb   <- c( 1 ,  1 ,  1 ,  2 ,  2 ,  3 ,  3 ,  3 ,  3 ,  3 ,  3 ,  4 ,  4 ,  4 ,  4 ,  4 ,  4 ,  4 ,  4 ,  4 ,  4  , 5 )\n  ##        charged/basic    -acid-    ------------polar/uncharged---------    -------------hydrophibic-------------\n  # The values above are the default ones.\n  # Below is the code to load them from the inputs and give them their proper codes\n  # The reactive expressions are evaluated inside netPlot() and wheelPlot() to create the amin and hb variables\n  getAmin <- reactive(toupper(unlist(strsplit(paste0(c(input$grp1, input$grp2, input$grp3, input$grp4, input$grp5), collapse = \"\"), \"\"))))\n  \n  gethb <- reactive(c(rep(1, nchar(input$grp1)), rep(2, nchar(input$grp2)), rep(3, nchar(input$grp3)), \n          rep(4, nchar(input$grp4)), rep(5, nchar(input$grp5))))\n  \n  \n  # The 'X' aminoacid represents any aminoacid. All characters not present in amin will be replaced with X, unless a 3-letter format is detected\n  \n  amin3 <-c(R = \"Arg\", H = \"His\", K = \"Lys\", D = \"Asp\", E = \"Glu\", S = \"Ser\", T = \"Thr\", N = \"Asn\",\n            Q = \"Gln\", C = \"Cys\", U = \"Sec\", G = \"Gly\", P = \"Pro\", A = \"Ala\", V = \"Val\", I = \"Ile\",\n            L = \"Leu\", M = \"Met\", F = \"Phe\", Y = \"Tyr\", W = \"Trp\")\n  \n  # Peptide groups in terms of bonds, some do miss\n  \n#   nonpolar <- c(\"V\", \"I\", \"L\", \"M\", \"F\", \"Y\", \"W\")\n#   acid <- c(\"D\", \"E\")\n#   basic <- c(\"R\", \"H\", \"K\")\n#   hydrobond <- c(\"S\", \"N\", \"Q\")\n  \n  getBonds <- reactive(lapply(list(input$grpNonpolar,\n                            input$grpAcid,\n                            input$grpBasic,\n                            input$grpHydro), function(i) unlist(strsplit(i, \"\"))))\n  \n  #### Code for Helical Net ####\n  \n  getHeight <- function() {\n    pepSeq <- input$seq\n    n <- nchar(pepSeq)\n    rws <- (n*1.5)/5.4\n    # The 120 factor is empirical, it creates the final height \n    # to make sure the symbols have proportional dimensions\n    height <- 120*rws\n    height\n  }\n  \n  getWidth <- function() {\n    300 + input$netWidth  \n  }\n  \n  lastNet <- NULL\n  \n  countFunc <- reactive({\n    seq <- input$seq\n    output$resCount <- renderUI(helpText(seq, style = \"font-family:monospace; margin: 0 12px; font-size: 16px; \"))\n    n <- nchar(seq)\n    counts <- paste0(paste(rep(c(1:9, 0), 10)[1:n], collapse = \"\"), \"(\", n, \")\")\n    output$seqMono <- renderUI(helpText(counts,\n                                        style = \"font-family:monospace; margin: 0 12px; font-size: 16px; \"))\n  })\n\n  netPlot <- function() {\n    pepSeq <- toupper(input$seq)\n    amin <- getAmin()\n    hb <- gethb()\n    n <- nchar(pepSeq)\n    \n    bondsInpt <- getBonds()\n    \n    nonpolar <- bondsInpt[[1]]\n    acid <- bondsInpt[[2]]\n    basic <- bondsInpt[[3]]\n    hydrobond <- bondsInpt[[4]]\n    \n    #output$resNumber <- renderUI(helpText(paste(\"Number of residues:\", n)))\n    #resCount <- paste(rep(c(1:9, 0), 10)[1:n], collapse = \"\")\n    \n    countFunc()\n    \n    intercept <- 0\n    \n    ###### Projection properties inputs\n    prop_fact <- input$netProp #3\n    #diameter <- input$netDiameter #4.6\n    #pitch <- input$netPitch/prop_fact # 5.4/prop_fact\n    #trans <- input$netTrans/prop_fact # 1.5/prop_fact\n    y0 = input$netStartOff/prop_fact #0\n    perturn <- input$netPerTurn #3.6\n    netDir <- as.numeric(input$netDirection)\n    #######\n    \n    ####### Other projection graphic inputs\n    marl <- input$netPadL \n    marr <- input$netPadR\n    padtop <- input$netPadTop\n    padbot <- input$netPadBot\n    netwd <- input$netWidth/60\n    #######\n    \n    ####### This values are in Angstrons for the alpa helix, but in practice they can be fixed\n    # The residues per turn is enough to actually change the position of the residues\n    diameter <- 4.6\n    pitch <- 5.4/prop_fact\n    trans <- 1.5/prop_fact\n    #######\n    \n    x0 <- diameter/5\n    \n    ymax <- max(n)*trans+y0\n    ny <- seq(from = ymax, by = -trans, length.out = n)\n    nx1 <- (ny[1]-intercept)*(diameter/pitch)\n    nx <- seq(from = nx1, by = -netDir*diameter/perturn, length.out = n)\n    #nx <- (ny-intercept)*(diameter/pitch)\n    nx <- ifelse(nx > diameter, nx-(nx%/%diameter)*diameter, nx)\n    \n    par(mar=c(0,0,0,0) + 0.1)\n#    plot(1, type = \"n\", xlim = c(0, 4.6), ylim = c(min(ny)-trans, ymax+trans))\n    plot(1, type = \"n\", xlim = c(-marl, diameter + marr + netwd), \n         ylim = c(min(ny)-trans-padbot, ymax+trans+padtop),\n         xaxt = \"n\", yaxt = \"n\", xlab = \"\", ylab = \"\",\n         xaxs = \"i\", yaxs = \"i\", frame.plot = input$showBoxNet == \"Yes\")\n\n    if (input$netShowLimits == \"Yes\") abline(v=c(intercept, diameter), lty = 2)\n    \n    xymat <- do.call(rbind, lapply(seq_len(n), function(i) {\n      if (diameter - nx[i] < x0 && diameter - nx[i] > 0) {\n        # Close to right border\n        matrix(c(nx[i]-diameter, nx[i], rep(ny[i], 2), rep(i, 2), c(0, 1)),\n               ncol = 4)\n      } else if(nx[i]-intercept < x0) {\n        # Close to left border\n        matrix(c(nx[i], nx[i]+diameter, rep(ny[i], 2), rep(i, 2), c(1, 0)),\n               ncol = 4)\n      } else {\n        matrix(c(nx[i], ny[i], i, 1), ncol = 4)\n      }\n    }))\n    \n    ptx <- xymat[,1]\n    pty <- xymat[,2]\n    ptn <- xymat[,3]\n    ptr <- xymat[,4]\n    \n    # Setting the sizes of the polygons. \n    # The /2/2 divisions just allows for the same input range even with different output sizes for net and wheel\n    lfrac <- input$circsize/2\n    l <- diameter*lfrac/2\n    # One prop value is created for each unique residue, but it's repeated for residues which will be plotted twice using [ptn]\n    l.prop <- sqrt(seq(input$circprop, 1, length.out = n))[ptn]\n    \n    l.prop <- l.prop/max(l.prop)\n    \n    # Adding guides behind\n    \n    if (input$showNetGuide == \"Yes\") {\n      ltyNetGuide <- as.numeric(input$netGuideLty)\n      lwdNetGuide <- as.numeric(input$netGuideLwd)\n      colNetGuide <- gray(1-as.numeric(input$netGuideCol))\n      \n      #ord <- order(pty, sort(ptx))\n      lines(ptx[ptr==1], pty[ptr==1], lty = ltyNetGuide, lwd = lwdNetGuide, col = colNetGuide) \n    }\n    \n    res <- unlist(strsplit(pepSeq, \"\"))[ptn]\n    fills <- hb[match(res, amin)]\n    \n    shp <- c(input$shp1, input$shp2, input$shp3, input$shp4, input$shp5)\n    cores <- c(input$col1, input$col2, input$col3, input$col4, input$col5)\n    bordersShow <- c(input$circBorder1, input$circBorder1,\n                     input$circBorder3, input$circBorder4, input$circBorder5)\n    \n    if (any(bordersShow == \"Yes\")) {\n      bordersCol <- c(input$circBorderCol1, input$circBorderCol2,\n                      input$circBorderCol3, input$circBorderCol4, input$circBorderCol5)\n      bordersCol[bordersShow != \"Yes\"] <- NA\n      bordersCol <- bordersCol[fills]\n      bordersWd <- as.numeric(c(input$circBorderWd1, input$circBorderWd2,\n                                input$circBorderWd3, input$circBorderWd4, input$circBorderWd5))\n      bordersCol[bordersWd <= 0] <- NA\n      bordersWd <- ifelse(bordersWd == 0, 1, bordersWd)\n      bordersWd <- bordersWd[fills]\n    } else {\n      bordersCol <- rep(NA, length(ptn))\n      bordersWd <- rep(1, length(ptn))\n    }\n    \n    shapes <- shp[fills]\n    \n    nres <- length(ptn)\n    numLabs <- c(input$labCol1, input$labCol2, input$labCol3, input$labCol4, input$labCol5)\n    \n    # Making labels\n    labType <- as.numeric(input$labType)\n    \n    resLab <-  if (labType == 0) {\n      \"\"\n    } else if (labType == 1) {\n      res\n    } else if (labType == 2) {\n      amin3[res]\n    } else if (labType == 3) {\n      paste0(res, ptn+input$labOffPos)\n    } else if (labType == 4) {\n      ptn+input$labOffPos\n    }\n    \n    bondWd <- c(nonpolar = input$bond1Wd, acba = input$bond2Wd, hydro = input$bond3Wd)\n    bondTy <- c(nonpolar = input$bond1Ty, acba = input$bond2Ty, hydro = input$bond3Ty)\n    bondCol <- c(nonpolar = input$bond1Col, acba = input$bond2Col, hydro = input$bond3Col)\n    \n    #Looping over residues to add their polygons/bonds\n    \n    for (i in seq_len(nres)) {\n      # Detecting Bonds \n      \n      if (input$netShowInteractions == \"Yes\") {\n      \n        bond3 <- TRUE\n        next3 <- which(ptn == ptn[i] + 3)[1]\n        \n        if (res[i] %in% nonpolar && res[next3] %in% nonpolar) {\n          bond3type <- \"nonpolar\"\n        } else if ((res[i] %in% basic && res[next3] %in% acid) ||\n                   (res[i] %in% acid && res[next3] %in% basic)) {\n          bond3type <- \"acba\"\n        } else if (res[i] %in% hydrobond && res[next3] %in% hydrobond) {\n          bond3type <- \"hydro\"\n        } else {\n          bond3 <- FALSE\n          bond3type <- \"none\"\n        } \n        \n        bond4 <- TRUE\n        next4 <- which(ptn == ptn[i] + 4)[1]\n        if (res[i] %in% nonpolar && res[next4] %in% nonpolar) {\n          bond4type <- \"nonpolar\"\n        } else if ((res[i] %in% basic && res[next4] %in% acid) ||\n                   (res[i] %in% acid && res[next4] %in% basic)) {\n          bond4type <- \"acba\"\n        } else if (res[i] %in% hydrobond && res[next4] %in% hydrobond) {\n          bond4type <- \"hydro\"\n        } else {\n          bond4 <- FALSE\n          bond4type <- \"none\"\n        } \n        # Adding bonds\n       \n        if (input$netDirection == \"1\") {\n          # The min/max choice for broken bonds depends on the direction of the net\n          # We select the min or max functions to be the extremes depending on the direction\n          ext1 <- max\n          ext2 <- min\n        } else {\n          ext1 <- min\n          ext2 <- max\n        }\n        \n        lty3 <- if(nchar(bondTy[bond3type]) > 1) bondTy[bond3type] else as.numeric(bondTy[bond3type])\n        lty4 <- if(nchar(bondTy[bond4type]) > 1) bondTy[bond4type] else as.numeric(bondTy[bond4type])\n        \n        if (bond3) {\n          segments(x0 = ptx[i], y0 = pty[i]-l,\n                   x1 = ptx[i]-((diameter/perturn)*3-diameter)*netDir,\n                   y1 = pty[i]-3*trans+l,\n                   lwd = as.numeric(bondWd[bond3type]), lty = lty3,\n                   col = bondCol[bond3type])\n        }\n  \n        if (bond4) {\n          segments(x0 = ptx[i], y0 = pty[i]-l,\n                   x1 = ptx[i]-((diameter/perturn)*4-diameter)*netDir,\n                   y1 = pty[i]-4*trans+l,\n                   lwd = as.numeric(bondWd[bond4type]), lty = lty4,\n                   col = bondCol[bond4type])\n        }\n      }\n        \n      # Adding Residues Polygons\n      bwd <- bordersWd[i]\n      addPolygon(shape = shapes[i], \n                 x = ptx[i], y = pty[i],\n                 size = l*l.prop[i], col = cores[fills][i],\n                 lwd = bwd, border = bordersCol[i])\n      \n    }\n    \n    # Fill styles\n    \n    circsFills <- c(input$fill1, input$fill2, input$fill3, input$fill4, input$fill5)\n    \n    styles <- circsFills[fills]\n    \n    styles.angs <- c(n = -1, h = 0, v = 90, `d/` = 45, `d\\\\` = -45)\n    \n    if (all(!is.na(styles)) && any(styles != \"n\")) {\n      nFills <- as.numeric(c(input$nFills1, input$nFills2, input$nFills3, input$nFills4, input$nFills5))\n      nFills <- nFills[fills]\n      fillCol <- c(input$fillCol1, input$fillCol2, input$fillCol3, input$fillCol4, input$fillCol5)\n      fillCol <- fillCol[fills]\n      angs.pattern <- styles.angs[match(styles, names(styles.angs))]\n      for (i in seq_len(nres)) {\n        if (!is.na(styles[i]) && styles[i] != \"n\" && shapes[i] == \"Circle\") {\n          circStripes(r = l, n = nFills[i],\n                      x = ptx[i], y = pty[i],\n                      angle = angs.pattern[i], col = fillCol[i])\n        }\n      }\n    }\n    \n    labOffX <- input$labOffX/5\n    labOffY <- input$labOffY/5\n    \n    text(ptx + l*(sign(labOffX)) + labOffX, \n         pty + l*(sign(labOffY)) + labOffY,\n         label = resLab,\n         cex = input$labCex/10, font = as.numeric(input$labFont),\n         col = numLabs[fills])\n    \n    ### Adding a white rectangular to cover residues plotted outside of the region of interest\n    \n    polygon(x = c(diameter + marr, diameter + marr + netwd, diameter + marr + netwd, diameter + marr),\n            y = c(ymax+trans+padtop, ymax+trans+padtop, min(ny)-trans-padbot, min(ny)-trans-padbot),\n            col = \"white\", border = NA)\n    \n    \n    ### Legend adding code:\n    \n    # The 2 lines below check which characters given as a Sequence are present in each groups, in order to only add the necessary legends\n    grpSplit <- split(getAmin(), gethb())\n    groupsPresent <- sapply(grpSplit, function(gp) any(strsplit(pepSeq, \"\")[[1]] %in% gp))\n    \n    if (input$showLeg == \"Yes\") {\n      legLab <- c(input$leg1, input$leg2, input$leg3, input$leg4, input$leg5)[groupsPresent]\n      legFill <- c(input$col1, input$col2, input$col3, input$col4, input$col5)[groupsPresent]\n      #       if (!grepl(\"X\", pepSeq)) {\n      #         legLab <- legLab[1:4]\n      #         legFill <- legFill[1:4]\n      #       }\n      \n      # Defining a legend function to avoid repeating the same arguments below if necessary\n      \n      my.leg <- function(...) legend(x = diameter + input$legX*5 - 4, \n                                     y = ymax+trans+padtop + input$legY*5 - 5.5, \n                                     legend = legLab,\n                                     bty = \"n\", yjust = 0.5, cex = as.numeric(input$legCex)/10, ...)\n      \n      # Now just calls with standard arguments and colouring fill\n      \n      #polygon(x = input$legX, y = input$legY)\n      \n      my.leg(fill = legFill)\n      \n      # Adding pattern on legend\n      \n      angs.pattern <- styles.angs[match(circsFills, names(styles.angs))]\n      \n      if (any(!is.na(angs.pattern))) {\n        \n        legDen <- c(input$legDen1, input$legDen2, input$legDen3, input$legDen4, input$legDen5)\n        \n        my.leg(fill = ifelse(angs.pattern  == -1, adjustcolor(\"black\", 0), \"black\"),\n               density = ifelse(angs.pattern == -1, NA, legDen),\n               angle = angs.pattern)\n      }\n    }\n    \n    ### End of legend code.\n    \n    # Adding title/name. Later to be on top\n    \n    if (input$showTitle == \"Yes\") {\n      main <- input$txTitle\n      cex.main <- input$cexTitleNet/10\n      text(x = input$xTitleNet, y = input$yTitleNet, label = main,\n           cex = cex.main, adj = c(0.5, 0.5), font = 2)\n    }\n\n  }\n  \n  output$netPlot <- renderPlot(\n    # The auto option is disbled by default to avoid unecessary plot creation \n    # when another projection is being tested, since this is rather slow\n    # and require considerable resources when online\n    {\n      if(input$autoNet || is.null(lastNet)) {\n        netPlot()\n        lastNet <<- TRUE\n      } else {\n        plot(1:10, 1:10, type = \"n\", xaxt = \"n\", yaxt = \"n\", frame.plot = FALSE,\n             xlab = \"\", ylab = \"\", main = NA)\n        text(5, 7, cex=1.2,\n             labels = \"Check the 'Automatic Preview'\\nbox to see the results.\\n\\nThis can be a bit slow.\")\n      }\n    },\n    height = getHeight, width = getWidth)\n  \n  \n  #### Code for Helical Wheel ####\n  \n  # Wheel radius. Changing this just messes with some relative positions offsets.\n  r <- 10 #input$wheelsize # Raio do circulo grande  da figura\n  \n  lastWheel <- NULL\n  \n  helicalPlot <- function() {\n    amin <- getAmin()\n    hb <- gethb()\n    nHel <- input$period\n    perStep <- input$perStep\n    \n    #pos <- c(1, 6, 11, 16, 3, 8, 13, 18, 5, 10, 15, 2, 7, 12, 17, 4, 9, 14) \n    \n    # Creating the minimum positions for 18 residues\n    posMin <- 1\n    \n    for (i in 2:nHel) {\n      y <- posMin[i-1] + perStep + 1\n      if (y > nHel) y <- y - nHel\n      posMin[i] <- y\n    }\n    \n    # Reading the pepseq\n    pepSeq <- input$seq \n    \n    if ((nchar(gsub(\"[A-Z]\", \"\", pepSeq))/nchar(gsub(\"[a-z]\", \"\", pepSeq))) == 2) {\n      # Tries to detect 3-letter code and convert to 1-letter\n      pepSeq <- amin[match(pepSeq, amin3)]\n    } else {\n      # Converts everything to upper case. Making sure everything is matched and \n      # Also allows for unkown pep detection below safely\n      pepSeq <- toupper(pepSeq)\n      #updateTextInput(session, \"seq\", value = pepSeq)\n    }\n    \n    # Replacing every character that isn't in 'amin' with 'X'\n    splitSeq <- unlist(strsplit(pepSeq, \"\"))\n    anyAmin <- which(!splitSeq %in% amin)\n    if (length(anyAmin) > 0) {\n      splitSeq[anyAmin] <- \"X\"\n      pepSeq <- paste0(splitSeq, collapse = \"\")\n      #updateTextInput(session, \"seq\", value = pepSeq)\n    }\n    \n    # Number of aminoacids residues\n    nres <- nchar(pepSeq) \n    \n    #output$resNumber <- renderUI(helpText(paste(\"Number of residues:\", nres)))\n    #resCount <- paste(rep(c(1:9, 0), 10)[1:nres], collapse = \"\")\n    \n    countFunc()\n    \n    nHelicals <- ceiling(nres/nHel)\n    \n    angs <- seq(acos(0), acos(0)+2*pi, length.out = nHel + 1) #Angulos para posicao de cada circulo pequeno\n    # acos(0) garante que o primeiro angulo terá como resultado um circulo no eixo x = 0 e y = max(y)\n    # acos(0)+2*pi faz o circulo dar uma volta completa\n    # nres + 1 é utilizado pois o ultimo ponto sempre coincide com o primeiro. Criamos um a mais e depois removemos o excedente.\n    \n    nMin <- if(nres < 18) 1:18 else 1:nres\n    \n    angs <- rep(angs, nHelicals)[nMin]\n    \n    # Order of the circles. \n    pos <- rep(posMin, nHelicals)[nMin]\n    \n    perim <- 2*pi*r #Perimetro do circulo grande\n    \n    innerOff <- rep(seq(1, 1-input$innRatio, length.out = nres)[order(pos[1:nHel])], nHelicals)[nMin]\n    \n    rotDirection <- if(input$direction == \"Clockwise\") -1 else 1\n    \n    ptx <- innerOff * (rotDirection*r) * cos(angs) # Pontos x\n    \n    pty <- innerOff * r * sin(angs) # Pontos y\n    \n    # Creating factor to multiply x and y and make them smaller for other circles\n    \n    nestFact <- (1/((nMin-1)%/%nHel + 1))^(1-input$nestRatio)\n    \n    ptxOrd <- ptx[pos] * nestFact\n    \n    ptyOrd <- pty[pos] * nestFact\n    \n    res.ratio <- input$circprop # Razao entre o tamanho (raio) do menor circulo em relacao ao maior (1)\n    \n    r.res.prop <- seq(res.ratio, 1, length.out = length(nMin)) # Measure that will be used to define the size of the residue polygon\n    \n    r.res.prop <- sqrt(r.res.prop)\n    # The circles should have the area, not the radius, proportional do the position. This fixes it based on A = pi * r * r\n    # It's based on circles, but the sqrt idea is the same for other polygons.\n\n    res.space <- input$circsize # Tentativa: espaçamento entre circulos\n    \n    r.res <- rev((perim / sum(r.res.prop)) * r.res.prop * res.space) # Tentativa: raio dos circulos em função do raio total\n    \n    cores <- c(input$col1, input$col2, input$col3, input$col4, input$col5)\n    \n    res <- unlist(strsplit(pepSeq, \"\"))\n    \n    #par(mar = c(0,0,0,input$marR)+0.1, xpd = TRUE)\n    #mpar()\n    \n    par(mar = c(0, 0, input$marT, input$marR)+0.1, xpd = TRUE)\n    \n    plot(ptx, pty, xlim = c(min(ptx, na.rm = TRUE) - max(r.res, na.rm = TRUE),\n                            max(ptx, na.rm = TRUE) + max(r.res, na.rm = TRUE)),\n         ylim = c(min(pty, na.rm = TRUE) - max(r.res, na.rm = TRUE),\n                  max(pty, na.rm = TRUE) + max(r.res, na.rm = TRUE)),\n         type = \"n\", xaxt = \"n\", yaxt = \"n\", frame.plot = FALSE,\n         xlab = \"\", ylab = \"\", main = NA) # Preparando a area de plotagem, nao vai aparecer nada...\n    \n    \n    # Adding circles guides. Before other stuff to stay behind everything\n    \n    if (input$showWheelGuide == \"Yes\") {\n      angs.guide <- seq(0, 2*pi, length.out = nHel)\n      \n      ptx.guide <- - r * sin(angs.guide)\n      pty.guide <- r * cos(angs.guide)\n      \n      lty <- as.numeric(input$wheelGuideLty)\n      lwd <- as.numeric(input$wheelGuideLwd)\n      col <- gray(1-as.numeric(input$wheelGuideCol))\n      \n      for (nest in unique(nestFact)) {\n        lines(ptx.guide*nest, pty.guide*nest, lty = lty,\n              lwd = lwd, col = col)  \n      }\n    }\n    \n    line_grad <- seq(1-input$maxlinegray, 1-input$minlinegray, length.out = nres)\n    \n    for (i in rev(seq_len(nres-1))) { #Plotando as conexões. \n      # De tras para frente para sobreposicao ficar correta\n      sx0 <- ptxOrd[i]\n      sx1 <- ptxOrd[i+1]\n      sy0 <- ptyOrd[i]\n      sy1 <- ptyOrd[i+1]\n      segments(sx0, sy0, sx1, sy1, lwd = input$conLineWd, col =  gray(line_grad[i]))\n    }\n    \n    # This matches which circle is of which category to properly select the colors and grid styles\n    fills <- hb[match(res, amin)]\n    \n    bordersShow <- c(input$circBorder1, input$circBorder1,\n                     input$circBorder3, input$circBorder4, input$circBorder5)\n    \n    if (any(bordersShow == \"Yes\")) {\n      bordersCol <- c(input$circBorderCol1, input$circBorderCol2,\n                      input$circBorderCol3, input$circBorderCol4, input$circBorderCol5)\n      bordersCol[bordersShow != \"Yes\"] <- NA\n      bordersCol <- bordersCol[fills]\n      bordersWd <- as.numeric(c(input$circBorderWd1, input$circBorderWd2,\n                                input$circBorderWd3, input$circBorderWd4, input$circBorderWd5))\n      bordersCol[bordersWd <= 0] <- NA\n      bordersWd <- ifelse(bordersWd == 0, 1, bordersWd)\n      bordersWd <- bordersWd[fills]\n    } else {\n      bordersCol <- rep(NA, length(nMin))\n      bordersWd <- rep(1, length(nMin))\n    }\n    \n    # Ploting the polygons\n\n    shp <- c(input$shp1, input$shp2, input$shp3, input$shp4, input$shp5)\n    \n    shapes <- shp[fills]\n    \n    for (i in nMin) {\n      bwd <- bordersWd[i]\n      #if (is.na(bwd)) next # Avoiding errors with invalid lwd. NA throwns an error, skip because there's no circle to plot\n      bordersWd <- ifelse(bordersWd == 0, 1, bordersWd)\n      \n      addPolygon(shape = shapes[i], \n                 x = ptxOrd[i], y = ptyOrd[i],\n                 size = r.res[i], col = cores[fills][i],\n                 lwd = bwd, border = bordersCol[i])\n    }\n    \n    # Fill styles\n    \n    circsFills <- c(input$fill1, input$fill2, input$fill3, input$fill4, input$fill5)\n    \n    styles <- circsFills[fills]\n    \n    styles.angs <- c(n = -1, h = 0, v = 90, `d/` = 45, `d\\\\` = -45)\n    \n    if (any(styles != \"n\")) {\n      nFills <- as.numeric(c(input$nFills1, input$nFills2, input$nFills3, input$nFills4, input$nFills5))\n      nFills <- nFills[fills]\n      fillCol <- c(input$fillCol1, input$fillCol2, input$fillCol3, input$fillCol4, input$fillCol5)\n      fillCol <- fillCol[fills]\n      angs.pattern <- styles.angs[match(styles, names(styles.angs))]\n      for (i in nMin) {\n        if (!is.na(styles[i]) && styles[i] != \"n\" && shapes[i] == \"Circle\") {\n\n          circStripes(r = r.res[i], n = nFills[i],\n                      x = ptxOrd[i], y = ptyOrd[i],\n                      angle = angs.pattern[i], col = fillCol[i])\n        }\n      }\n    }\n    \n    # Using symbols is dangerous. The drawings are relative to the axis and drawings may be hard to position\n    #     symbols(ptxOrd, ptyOrd, circles = r.res, inches = FALSE, \n    #             add = TRUE, bg = cores[fills], \n    #             fg = circBorder, lwd = input$circBorderWd) #Plotando os circulos\n    \n    # Making labels\n    labType <- as.numeric(input$labType)\n    \n    resLab <-  if (labType == 0) {\n      \"\"\n    } else if (labType == 1) {\n      res\n    } else if (labType == 2) {\n      amin3[res]\n    } else if (labType == 3) {\n      paste0(res, seq_len(nres) + input$labOffPos)\n    } else if (labType == 4) {\n      seq_len(nres)\n    }\n    \n    labOffX <- input$labOffX\n    labOffY <- input$labOffY\n    \n    numLabs <- c(input$labCol1, input$labCol2, input$labCol3, input$labCol4, input$labCol5)\n    \n    text(ptxOrd + r.res*(sign(labOffX)) + labOffX,\n         ptyOrd + r.res*(sign(labOffY)) + labOffY,\n         label = resLab,\n         cex = input$labCex/10, font = as.numeric(input$labFont),\n         col = numLabs[fills])\n    \n    # Adding the residues number\n    \n    if (input$numShow == \"Yes\") {\n      numOffY <- input$numOffY\n      numOffX <- -input$numOffX\n      \n      numCols <- c(input$numCol1, input$numCol2, input$numCol3, input$numCol4, input$numCol5)\n      \n      text(ptxOrd - r.res*(sign(numOffX)) - numOffX, \n           ptyOrd - r.res*(sign(numOffY)) - numOffY, \n           labels = seq_len(nres) + input$numOffPos, cex = input$numCex/10, \n           font = as.numeric(input$numFont),\n           col = numCols[fills]) \n    }\n    \n    \n    ### Legend adding code:\n    \n    # The 2 lines below check which characters given as a Sequence are present in each groups, in order to only add the necessary legends\n    grpSplit <- split(getAmin(), gethb())\n    groupsPresent <- sapply(grpSplit, function(gp) any(strsplit(pepSeq, \"\")[[1]] %in% gp))\n\n    if (input$showLeg == \"Yes\") {\n      legLab <- c(input$leg1, input$leg2, input$leg3, input$leg4, input$leg5)[groupsPresent]\n      legFill <- c(input$col1, input$col2, input$col3, input$col4, input$col5)[groupsPresent]\n#       if (!grepl(\"X\", pepSeq)) {\n#         legLab <- legLab[1:4]\n#         legFill <- legFill[1:4]\n#       }\n      \n      # Defining a legend function to avoid repeating the same arguments below if necessary\n      \n      my.leg <- function(...) legend(x = r*input$legX, y = r*input$legY, \n                                     legend = legLab,\n                                     bty = \"n\", yjust = 0.5, cex = as.numeric(input$legCex)/10, ...)\n      \n      # Now just calls with standard arguments and colouring fill\n\n      my.leg(fill = legFill)\n      \n      # Adding pattern on legend\n      \n      angs.pattern <- styles.angs[match(circsFills, names(styles.angs))]\n      \n      if (any(!is.na(angs.pattern))) {\n        \n        legDen <- c(input$legDen1, input$legDen2, input$legDen3, input$legDen4, input$legDen5)\n        \n        my.leg(fill = ifelse(angs.pattern  == -1, adjustcolor(\"black\", 0), \"black\"),\n               density = ifelse(angs.pattern == -1, NA, legDen),\n               angle = angs.pattern)\n      }\n    }\n    \n    ### End of legend code.\n    \n    # Adding title/name. Later to be on top\n    \n    if (input$showTitle == \"Yes\") {\n      main <- input$txTitle\n      cex.main <- input$cexTitle/10\n      text(x = input$xTitle, y = input$yTitle, label = main,\n           cex = cex.main, adj = c(0.5, 0.5), font = 2)\n    }\n    \n    # Adding outer box to help exporting\n    \n    if (input$showBox == \"Yes\") {\n      box(\"outer\") \n    }\n    \n  }\n  \n  imgWd <- reactive(input$figWd)\n  #getSeq <- reactive(input$seq)\n  \n  output$helicalPlot <- renderPlot({\n    # The auto option is disbled by default to avoid unecessary plot creation \n    # when another projection is being tested, since this is rather slow\n    # and require considerable resources when online\n    if(input$autoWheel || is.null(lastWheel)) {\n      helicalPlot()\n      lastWheel <<- recordPlot()\n    } else {\n      plot(1:10, 1:10, type = \"n\", xaxt = \"n\", yaxt = \"n\", frame.plot = FALSE,\n           xlab = \"\", ylab = \"\", main = NA)\n      text(5, 7, cex = 1.5,\n           labels = \"Check the 'Automatic Preview'\\nbox to see the results.\\n\\nThis can be a bit slow.\")\n    }\n  },\n  height = 600, width = imgWd)\n  \n  #shinyjs::disable(\"wheelsize\")\n  \n  # Use sequence as title\n  observeEvent(input$titleSeq, {\n    updateSelectInput(session, \"showTitle\", selected = \"Yes\")\n    updateTextInput(session, \"txTitle\", value = input$seq)\n    nc <- nchar(input$seq)\n    cexFit <- round(0.0325*nc^2 - 2.275*nc + 49.5, 1)\n    updateNumericInput(session, \"cexTitle\", value = cexFit)\n  })\n  \n  # Reseting and style buttons\n  \n  observeEvent(input$reset_input, {\n    shinyjs::reset(\"side-panel\")\n  })\n  \n  observeEvent(input$reset_input2, {\n    shinyjs::reset(\"settings\")\n  })\n  \n  observeEvent(input$grpReset, {\n    updateTextInput(session, \"grp1\", value = \"RHK\")\n    updateTextInput(session, \"grp2\", value = \"DE\")\n    updateTextInput(session, \"grp3\", value = \"STNQCU\")\n    updateTextInput(session, \"grp4\", value = \"AGVILMFYWP\")\n    updateTextInput(session, \"grp5\", value = \"X\")\n  })\n  \n  observeEvent(input$grpBondReset, {\n    updateTextInput(session, \"grpNonpolar\", value = \"VILMFYW\")\n    updateTextInput(session, \"grpHydro\", value = \"SNQ\")\n    updateTextInput(session, \"grpAcid\", value = \"DE\")\n    updateTextInput(session, \"grpBasic\", value = \"RHK\")\n  })\n  \n  observeEvent(input$netAutoMar, {\n    nc <- nchar(input$seq)\n    updateNumericInput(session, \"yTitleNet\", value = round(nc*0.51+0.5, 1))\n    updateNumericInput(session, \"netPadTop\", value = 0.5)\n  })\n  \n  observeEvent(input$style_gray, {\n    shinyjs::updateColourInput(session = session, inputId = \"col1\", value = \"black\")\n    updateTextInput(session = session, inputId = \"circBorder1\", value = \"No\")\n    shinyjs::updateColourInput(session = session, inputId = \"circBorderCol1\", value = \"#000000\")\n    shinyjs::updateColourInput(session = session, inputId = \"labCol1\", value = \"#FFFFFF\")\n    shinyjs::updateColourInput(session = session, inputId = \"col2\", value = \"gray30\")\n    updateTextInput(session = session, inputId = \"circBorder1\", value = \"No\")\n    shinyjs::updateColourInput(session = session, inputId = \"circBorderCol2\", value = \"#000000\")\n    shinyjs::updateColourInput(session = session, inputId = \"labCol2\", value = \"#FFFFFF\")\n    shinyjs::updateColourInput(session = session, inputId = \"col3\", value = \"gray50\")\n    updateTextInput(session = session, inputId = \"circBorder3\", value = \"No\")\n    shinyjs::updateColourInput(session = session, inputId = \"circBorderCol3\", value = \"#000000\")\n    shinyjs::updateColourInput(session = session, inputId = \"labCol3\", value = \"#000000\")\n    shinyjs::updateColourInput(session = session, inputId = \"col4\", value = \"gray80\")\n    updateTextInput(session = session, inputId = \"circBorder4\", value = \"No\")\n    shinyjs::updateColourInput(session = session, inputId = \"circBorderCol4\", value = \"#000000\")\n    shinyjs::updateColourInput(session = session, inputId = \"labCol4\", value = \"#000000\")\n    shinyjs::updateColourInput(session = session, inputId = \"col5\", value = \"white\")\n    updateTextInput(session = session, inputId = \"circBorder5\", value = \"Yes\")\n    shinyjs::updateColourInput(session = session, inputId = \"circBorderCol5\", value = \"#000000\")\n    shinyjs::updateColourInput(session = session, inputId = \"labCol5\", value = \"#000000\")\n  })\n  \n  terColors <- substr(terrain.colors(5), 0, 7)\n  observeEvent(input$style_terrain, {\n    shinyjs::updateColourInput(session = session, inputId = \"col1\", value = terColors[1])\n    updateTextInput(session = session, inputId = \"circBorder1\", value = \"No\")\n    shinyjs::updateColourInput(session = session, inputId = \"circBorderCol1\", value = \"#000000\")\n    shinyjs::updateColourInput(session = session, inputId = \"labCol1\", value = \"#000000\")\n    shinyjs::updateColourInput(session = session, inputId = \"col2\", value = terColors[2])\n    updateTextInput(session = session, inputId = \"circBorder1\", value = \"No\")\n    shinyjs::updateColourInput(session = session, inputId = \"circBorderCol2\", value = \"#000000\")\n    shinyjs::updateColourInput(session = session, inputId = \"labCol2\", value = \"#000000\")\n    shinyjs::updateColourInput(session = session, inputId = \"col3\", value = terColors[3])\n    updateTextInput(session = session, inputId = \"circBorder3\", value = \"No\")\n    shinyjs::updateColourInput(session = session, inputId = \"circBorderCol3\", value = \"#000000\")\n    shinyjs::updateColourInput(session = session, inputId = \"labCol3\", value = \"#000000\")\n    shinyjs::updateColourInput(session = session, inputId = \"col4\", value = terColors[4])\n    updateTextInput(session = session, inputId = \"circBorder4\", value = \"No\")\n    shinyjs::updateColourInput(session = session, inputId = \"circBorderCol4\", value = \"#000000\")\n    shinyjs::updateColourInput(session = session, inputId = \"labCol4\", value = \"#000000\")\n    shinyjs::updateColourInput(session = session, inputId = \"col5\", value = terColors[5])\n    updateTextInput(session = session, inputId = \"circBorder5\", value = \"Yes\")\n    shinyjs::updateColourInput(session = session, inputId = \"circBorderCol5\", value = \"#000000\")\n    shinyjs::updateColourInput(session = session, inputId = \"labCol5\", value = \"#000000\")\n  })\n  \n  observeEvent(input$style_bw, {\n    shinyjs::updateColourInput(session = session, inputId = \"col1\", value = \"#FFFFFF\")\n    updateTextInput(session = session, inputId = \"circBorder1\", value = \"Yes\")\n    updateNumericInput(session = session, inputId = \"circBorderWd1\", value = 5)\n    shinyjs::updateColourInput(session = session, inputId = \"circBorderCol1\", value = \"#000000\")\n    shinyjs::updateColourInput(session = session, inputId = \"labCol1\", value = \"#000000\")\n    updateSelectInput(session = session, inputId = \"fill1\", selected = \"n\")\n    updateNumericInput(session = session, inputId = \"nFills1\", value = \"4\")\n    shinyjs::updateColourInput(session = session, inputId = \"fillCol1\", value = \"#FFFFFF\")\n    \n    shinyjs::updateColourInput(session = session, inputId = \"col2\", value = \"#FFFFFF\")\n    updateTextInput(session = session, inputId = \"circBorder1\", value = \"Yes\")\n    updateNumericInput(session = session, inputId = \"circBorderWd2\", value = 4)\n    shinyjs::updateColourInput(session = session, inputId = \"circBorderCol2\", value = \"#000000\")\n    shinyjs::updateColourInput(session = session, inputId = \"labCol2\", value = \"#000000\")\n    updateSelectInput(session = session, inputId = \"fill2\", selected = \"v\")\n    updateNumericInput(session = session, inputId = \"nFills2\", value = \"4\")\n    shinyjs::updateColourInput(session = session, inputId = \"fillCol2\", value = \"#000000\")\n    \n    shinyjs::updateColourInput(session = session, inputId = \"col3\", value = \"#FFFFFF\")\n    updateTextInput(session = session, inputId = \"circBorder3\", value = \"Yes\")\n    updateNumericInput(session = session, inputId = \"circBorderWd3\", value = 3)\n    shinyjs::updateColourInput(session = session, inputId = \"circBorderCol3\", value = \"#000000\")\n    shinyjs::updateColourInput(session = session, inputId = \"labCol3\", value = \"#000000\")\n    updateSelectInput(session = session, inputId = \"fill3\", selected = \"h\")\n    updateNumericInput(session = session, inputId = \"nFills3\", value = \"5\")\n    shinyjs::updateColourInput(session = session, inputId = \"fillCol3\", value = \"#000000\")\n    \n    shinyjs::updateColourInput(session = session, inputId = \"col4\", value = \"#FFFFFF\")\n    updateTextInput(session = session, inputId = \"circBorder4\", value = \"Yes\")\n    shinyjs::updateColourInput(session = session, inputId = \"circBorderCol4\", value = \"#000000\")\n    updateNumericInput(session = session, inputId = \"circBorderWd4\", value = 2)\n    shinyjs::updateColourInput(session = session, inputId = \"labCol4\", value = \"#000000\")\n    updateSelectInput(session = session, inputId = \"fill4\", selected = \"d/\")\n    updateNumericInput(session = session, inputId = \"nFills4\", value = \"6\")\n    shinyjs::updateColourInput(session = session, inputId = \"fillCol4\", value = \"#000000\")\n    \n    shinyjs::updateColourInput(session = session, inputId = \"col5\", value = \"#FFFFFF\")\n    updateTextInput(session = session, inputId = \"circBorder5\", value = \"Yes\")\n    updateNumericInput(session = session, inputId = \"circBorderWd5\", value = 1)\n    shinyjs::updateColourInput(session = session, inputId = \"circBorderCol5\", value = \"#000000\")\n    shinyjs::updateColourInput(session = session, inputId = \"labCol5\", value = \"#000000\")\n    updateSelectInput(session = session, inputId = \"fill5\", selected = \"d\\\\\")\n    updateNumericInput(session = session, inputId = \"nFills5\", value = \"3\")\n    shinyjs::updateColourInput(session = session, inputId = \"fillCol5\", value = \"#000000\")\n    \n    updateNumericInput(session = session, inputId = \"maxlinegray\", value = 1)\n    updateNumericInput(session = session, inputId = \"minlinegray\", value = 1)\n    updateNumericInput(session = session, inputId = \"conLineWd\", value = 1)\n  })\n  \n  observeEvent(input$style_labdown, {\n    current <- input$labType\n    \n    if (current == \"0\") {\n      updateSelectInput(session = session, inputId = \"numShow\", selected = \"Yes\")\n      updateSelectInput(session = session, inputId = \"labType\", selected = \"1\")\n      updateNumericInput(session = session, inputId = \"labOffY\", value = 0)\n      updateNumericInput(session = session, inputId = \"lnumOffY\", value = -0.3)\n    } else if (current == \"1\") {\n      updateSelectInput(session = session, inputId = \"labType\", selected = \"2\")\n    } else if (current == \"2\") {\n      updateSelectInput(session = session, inputId = \"numShow\", selected = \"No\")\n      updateSelectInput(session = session, inputId = \"labType\", selected = \"3\")\n      updateNumericInput(session = session, inputId = \"labOffY\", value = -0.3)\n    } else if (current == \"3\") {\n      if (input$labOffY == -0.3) {\n        updateNumericInput(session = session, inputId = \"labOffY\", value = 0)\n      } else {\n        updateSelectInput(session = session, inputId = \"numShow\", selected = \"No\")\n      updateSelectInput(session = session, inputId = \"labType\", selected = \"0\")\n      }\n    } \n    shinyjs::updateColourInput(session = session, inputId = \"labCol1\", value = \"#000000\")\n    shinyjs::updateColourInput(session = session, inputId = \"labCol2\", value = \"#000000\")\n    shinyjs::updateColourInput(session = session, inputId = \"labCol3\", value = \"#000000\")\n    shinyjs::updateColourInput(session = session, inputId = \"labCol4\", value = \"#000000\")\n    shinyjs::updateColourInput(session = session, inputId = \"labCol5\", value = \"#000000\")\n    \n  })\n  \n  observeEvent(input$style_round, {\n    if (input$innRatio != 0) {\n      updateNumericInput(session, \"innRatio\", value = 0)\n    } else {\n      updateNumericInput(session, \"innRatio\", value = 0.4)  \n    }\n  })\n  \n  observeEvent(input$style_pattern, {\n    \n    if (any(c(input$fill1, input$fill2, input$fill3, input$fill4, input$fill5) %in% c(\"v\", \"h\", \"d/\", \"d\\\\\"))) {\n      updateSelectInput(session = session, inputId = \"fill1\", selected = \"n\")\n      updateSelectInput(session = session, inputId = \"fill2\", selected = \"n\")\n      updateSelectInput(session = session, inputId = \"fill3\", selected = \"n\")\n      updateSelectInput(session = session, inputId = \"fill4\", selected = \"n\")\n      updateSelectInput(session = session, inputId = \"fill5\", selected = \"n\")\n    } else {\n      updateSelectInput(session = session, inputId = \"fill1\", selected = \"n\")\n      updateSelectInput(session = session, inputId = \"fill2\", selected = \"v\")\n      updateSelectInput(session = session, inputId = \"fill3\", selected = \"h\")\n      updateSelectInput(session = session, inputId = \"fill4\", selected = \"d/\")\n      updateSelectInput(session = session, inputId = \"fill5\", selected = \"d\\\\\") \n    }\n  })\n  observeEvent(input$style_legend, {\n    if (input$showLeg == \"No\") {\n      updateSelectInput(session, \"showLeg\", selected = \"Yes\")\n      updateNumericInput(session, \"figWd\", value = 775)\n      updateNumericInput(session, \"marR\", value = 12)\n      updateNumericInput(session, \"marT\", value = 0)\n    } else {\n      updateSelectInput(session, \"showLeg\", selected = \"No\")\n      updateNumericInput(session, \"figWd\", value = 600)\n      updateNumericInput(session, \"marR\", value = 0)\n      updateNumericInput(session, \"marT\", value = 0)\n    }\n  })\n  \n  observeEvent(input$style_netLeg0, {\n    updateSelectInput(session, \"showLeg\", selected = \"No\")\n    updateNumericInput(session, \"netWidth\", value = 0)\n    updateNumericInput(session, \"netProp\", value = 2.8)\n    updateNumericInput(session, \"netPadL\", value = 0.1)\n    updateNumericInput(session, \"netPadR\", value = 0.1)\n    updateNumericInput(session, \"netPadTop\", value = 0)\n  })\n  \n  observeEvent(input$style_netLeg1, {\n    updateSelectInput(session, \"showLeg\", selected = \"Yes\")\n    updateNumericInput(session, \"netWidth\", value = 0)\n    updateNumericInput(session, \"netProp\", value = 3.8)\n    updateNumericInput(session, \"netPadL\", value = 0.1)\n    updateNumericInput(session, \"netPadR\", value = 0.1)\n    updateNumericInput(session, \"legX\", value = -0.1)\n    updateNumericInput(session, \"legY\", value = 0.88)\n    updateNumericInput(session, \"netPadTop\", value = 2.2)\n  })\n  \n  observeEvent(input$style_netLeg2, {\n    updateSelectInput(session, \"showLeg\", selected = \"Yes\")\n    updateNumericInput(session, \"netWidth\", value = 240)\n    updateNumericInput(session, \"netProp\", value = 2.8)\n    updateNumericInput(session, \"netPadL\", value = 0.1)\n    updateNumericInput(session, \"netPadR\", value = 0.1)\n    updateNumericInput(session, \"legX\", value = 0.8)\n    updateNumericInput(session, \"legY\", value = 0.9)\n    updateNumericInput(session, \"netPadTop\", value = 0)\n  })\n\n  observeEvent(input$style_circle, {\n    updateSelectInput(session = session, inputId = \"shp1\", selected = \"Circle\")\n    updateSelectInput(session = session, inputId = \"shp2\", selected = \"Circle\")\n    updateSelectInput(session = session, inputId = \"shp3\", selected = \"Circle\")\n    updateSelectInput(session = session, inputId = \"shp4\", selected = \"Circle\")\n    updateSelectInput(session = session, inputId = \"shp5\", selected = \"Circle\")\n  })\n  \n  observeEvent(input$style_squares, {\n    updateSelectInput(session = session, inputId = \"shp1\", selected = \"Square\")\n    updateSelectInput(session = session, inputId = \"shp2\", selected = \"Square\")\n    updateSelectInput(session = session, inputId = \"shp3\", selected = \"Square\")\n    updateSelectInput(session = session, inputId = \"shp4\", selected = \"Square\")\n    updateSelectInput(session = session, inputId = \"shp5\", selected = \"Square\")\n  })\n  \n  observeEvent(input$style_shapes, {\n    updateSelectInput(session = session, inputId = \"shp1\", selected = \"Circle\")\n    updateSelectInput(session = session, inputId = \"shp2\", selected = \"Square\")\n    updateSelectInput(session = session, inputId = \"shp3\", selected = \"Triangle\")\n    updateSelectInput(session = session, inputId = \"shp4\", selected = \"Diamond\")\n    updateSelectInput(session = session, inputId = \"shp5\", selected = \"Hexagon\")\n  })\n  \n#   observeEvent(input$bt_rdata, {\n#     save.image(\"Image.RData\")\n#   })\n#   \n#   observeEvent(input$bt_rdataload, {\n#     load(\"Image.RData\")\n#   })\n\n  observeEvent(input$alphaHelix, {\n    updateNumericInput(session, \"netPerTurn\", value = 3.6)\n#     updateNumericInput(session, \"netDiameter\", value = 4.6)\n#     updateNumericInput(session, \"netPitch\", value = 5.4)\n#     updateNumericInput(session, \"netTrans\", value = 1.5)\n  })\n \n  observeEvent(input$three10Helix, {\n    updateNumericInput(session, \"netPerTurn\", value = 3)\n#     updateNumericInput(session, \"netDiameter\", value = 3.8)\n#     updateNumericInput(session, \"netPitch\", value = 6)\n#     updateNumericInput(session, \"netTrans\", value = 2)\n  })\n  \n  observeEvent(input$piHelix, {\n    updateNumericInput(session, \"netPerTurn\", value = 4.4)\n#     updateNumericInput(session, \"netDiameter\", value = 5.6)\n#     updateNumericInput(session, \"netPitch\", value = 4.8)\n#     updateNumericInput(session, \"netTrans\", value = 1.1)\n  })\n  \n  output$bt_export <- downloadHandler(\n    filename = function() {\n      \"HelicalWheelStyle.hws\"\n    },\n    content = function(file) {\n      vlist <- reactiveValuesToList(input)\n      # Remove this values because they aren't inputs and can be dangerous\n      vlist[c(\"fileImport\", \"shinyjs-resettable-settings\")] <- NULL\n      #print(vlist)\n      inputsList <- names(vlist)\n      exportVars <- paste0(inputsList, \"=\", sapply(inputsList, function(inpt) input[[inpt]]))\n      write(exportVars, file)\n    })\n  \n  importFile <- reactive({\n    \n    inFile <- input$fileImport\n    #print(\"a\")\n    if (is.null(inFile))\n      return(NULL)\n    \n    lines <- readLines(inFile$datapath)\n    out <- lapply(lines, function(l) unlist(strsplit(l, \"=\")))\n    #shinyjs::reset(\"fileImport\")\n    return(out)\n  })\n  \n  observe({\n    imp <- importFile()\n\n    if (!is.null(imp)) {\n      imp <- imp[order(sapply(imp, function(o) nchar(o[1])))]\n\n      for (inpt in imp) session$sendInputMessage(inpt[1], list(value = inpt[2]))\n      \n      # This is a workaround to make sure reuploading the file will work properly. \n      Sys.sleep(1)\n      session$sendCustomMessage(type = \"resetFileInputHandler\", 'fileImport')\n    }\n  })\n  \n  fname <- \"HelicalWheelProjection\"\n  \n  output$plotDown <- downloadHandler(\n    filename = function() {\n      paste(fname, tolower(input$expFormat), sep = \".\")\n    },\n    content = function(file) {\n      dpi <- input$expDPI\n      dims <- as.numeric(dpi)*c(input$figWd, 600)/72\n      if (input$expFormat == \"PNG\") {\n        png(file, res = dpi, width = dims[1], height = dims[2])\n      } else if (input$expFormat == \"TIFF (lzw)\") {\n        tiff(file, compression = \"lzw\", res = dpi, width = dims[1], height = dims[2])\n      } else if (input$expFormat == \"PDF\") {\n        pdf(file, width = input$figWd/72, height = 600/72)\n      } else if (input$expFormat == \"JPG\") {\n        jpeg(file, res = dpi, width = dims[1], height = dims[2], quality = 100)\n      }\n      par(mar = c(0, 0, input$marT, input$marR)+0.1, xpd = TRUE)\n      helicalPlot()\n      dev.off()\n    }\n  )\n  \n  fnameNet <- \"HelicalNetProjection\"\n  \n  output$plotDownNet <- downloadHandler(\n    filename = function() {\n      paste(fnameNet, tolower(input$expFormat), sep = \".\")\n    },\n    content = function(file) {\n      dpi <- input$expDPI\n      dims <- as.numeric(dpi)*c(getWidth(), getHeight())/72\n      ImgFormat <- input$expFormat\n      if (ImgFormat == \"PNG\") {\n        png(file, res = dpi, width = dims[1], height = dims[2])\n      } else if (ImgFormat == \"TIFF (lzw)\") {\n        tiff(file, compression = \"lzw\", res = dpi, width = dims[1], height = dims[2])\n      } else if (ImgFormat == \"PDF\") {\n        pdf(file, width = getWidth()/72, height = getHeight()/72)\n      } else if (ImgFormat == \"JPG\") {\n        jpeg(file, res = dpi, width = dims[1], height = dims[2], quality = 100)\n      }\n      par(mar=c(0,0,0,0) + 0.1)\n      netPlot()\n      dev.off()\n    }\n  )\n})\n",
    "created" : 1455399346704.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1713425860",
    "id" : "E89A57A6",
    "lastKnownWriteTime" : 1455399373,
    "path" : "F:/GitHub/NetWheels/server.R",
    "project_path" : "server.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "type" : "r_source"
}